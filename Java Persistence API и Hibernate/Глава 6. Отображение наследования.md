Основной стратегией отображения классов в таблицы БД может быть "одна таблица для каждого класса хранимой сущности". 
Объектно-ориентированные системы моделируют оба вида отношений: *является* (*is a*, то есть один класс является специализацией другого) и *имеет* (*has a*, в классе определена ссылка на экземпляр другого класса). Модели, основанные на SQL, поддерживают только отношение *имеет* (*has a*).

Существуют 4 стратегии представления иерархии наследования:
- одна таблица для каждого конкретного класса и полиморфное поведение по умолчанию во время выполнения;
- одна таблица для каждого конкретного класса, но полное исключение полиморфизма и отношений наследования из схемы SQL. Для полиморфного поведения во время выполнения необходимо использовать запросы с SQL инструкцией `UNION`;
- единая таблица для целой иерархии классов: полиморфизм поддерживается за счет денормализации схемы SQL, а определение суперкласса/подкласса осуществляется посредством различения строк;
- одна таблица для каждого подкласса: отношение *is a* (наследования) представлено в виде отношения *has a* (связь по внешнему ключу) с применением SQL-операции `JOIN`.

## 6.1 Одна таблица для каждого конкретного класса и неявный полиморфизм

Предположим, что мы выбрали простейший из предложенных вариантов: в точности одна таблица для каждого конкретного класса.

==вставить картинку== 6.1

Опираясь на такой неявный полиморфизм, каждый конкретный класс можно отобразить при помощи аннотации `@Entity`. **Свойства суперкласса по умолчанию игнорируются и не сохраняются!** Чтобы встроить свойства суперкласса в таблицы конкретных подклассов, необходимо отметить их аннотацией `@MappedSuperclass`.

В подклассе можно переопределить отображение одного или нескольких столюцов суперкласса, используя аннотации `@AttributeOverride` или `@AttrbuteOverrides`.

Также в суперклассе можно объявить свойство идентификатора, используя общие для всех подклассов имя столбца и стратегию, чтобы не повторять их объявления. Но это не обязательно.

Проблемы такого варианта:
- Главная проблема заключается в отсутствии достаточной поддержки полиморфных ассоциаций. Обычно в БД ассоциации представлены в виде связей по внешнему ключу. Если все подклассы отображаются на разные таблицы, полиморфные ассоциации с их суперклассом не могут быть представлены в виде простой связи по внешнему ключу.
- Проблему представляют полиморфные запросы, возвращающие экземпляры всех классов, реализующих запрашиваемый интерфейс. Hibernate должен выполнять запрос для суперкласса в виде нескольких SQL-выражений `SELECT` - по одному для каждого подкласса
- Другой проблемой является разделение одинаковой семантики несколькими разными столбцами в разных таблицах. Это сильно усложняет эволюцию схемы. большинство стандартных операций рефакторинга IDE потребует ручной доработки, поскольку автоматизированные процедуры вряд ли учитывают `@AttributeOverrides`.

## 6.2 Одна таблица для каждого конкретного класса с объединениями

Новая стратегия наследования под названием `TABLE_PER_CLASS`, объявляется в суперклассе.
```
@Entity
@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)
public abstract class BillingDetails {
	@Id
	@GeneratedValue(generator = Constants.ID_GENERATOR)
	protected Long id;
	
	@NotNull
	protected String owner;
	
	//...
}
```
В суперклассе должны иметься идентификатор в БД и его отображение, чтобы все подклассы могли использовать его в своих таблицах. В отличие от предыдущей стратегии, это условие обязательно. 

Все отображения конкретных классов наследуют хранимые свойства суперкласса (или интерфейса). Требуется только добавить аннотацию `@Entity`перед каждым классом.

```
@Entity
public class CreditCard extends BillingDetails {
	@NotNull
	protected String cardNumber;
	
	@NotNull
	protected String expMonth;
	
	@NotNull
	protected String expYear;
	//...
}
```

Схема SQL по-прежнему ничего не знает о наследовании - таблицы выглядят в точности как показано на [[рисунке 6.1]]

Стратегия `TABLE_PER_CLASS` не является обязательной и может поддерживаться не всеми реализациями JPA.

Если бы класс `BillingDetails` был конкретным, понадобилась бы дополнительная таблица для хранения экземпляров. Между таблицами в БД по-прежнему нет никаких отношений, кроме наличия некоторых одинаковых столбцов.
Преимущества данной стратегии станут очевидными после знакомства с полиморфными запросами. К примеру, запрос `select bd from BillingDetails bd` генерирует следующее выражение SQL:
```
select 
	ID, OWNER, EXPMONTH, EXPYEAR, CARDNUMBER, 
	ACCOUNT, BANKNAME, SWIFT, CLAZZ_
from 
	(select
		ID, OWNER, EXPMONTH, EXPYEAR, CARDNUMBER,
		null as ACCOUNT,
		null as BANKNAME,
		null as SWIFT,
		1 as CLAZZ_
	from
		CREDITCARD
	union all
	select
		ID, OWNER, 
		null as EXPMONTH, 
		null as EXPYEAR, 
		null as CARDNUMBER,
		ACCOUNT, BANKNAME, SWIFT,
		2 as CLAZZ_
	from
		BANKACCOUNT
	) as BILLINGDETAILS
```

Этот запрос `SELECT` использует подзапрос в предложении `FROM`для извлечения всех экземпляров класса `BillingDetails` из всех таблиц конкретных классов. Таблицы объединяются с помощью оператора `UNION`, а в промежуточный результат вставляются литералы (в данном случае 1 и 2); они нужны Hibernate для создания экземпляра правильного класса из данных в конкретной записи.
Объединение требует одинаковую структуру столбцов, поэтому вместо несуществующих, вставляется `NULL`.

Другим важным преимуществом является возможность применения полиморфных ассоциаций. Теперь стало возможным отобразить ассоциацию от класса `User` к классу `BillingDetails`. 
Hibernate может использовать запрос с выражением UNION для имитации единой таблицы в качестве цели отображения ассоциации.

## 6.3 Единая таблица для целой иерархии классов

Иерархию классов целиком можно отобразить в одну таблицу. Эта таблица будет содержать столбцы для всех полей каждого класса в иерархии. Конкретный подкласс, представляемый отдельной записью, определяется значением дополнительного столбца с селектором типа или формулой.
Данная стратегия отображения - лучшая с точки зрения производительности и простоты. Как полиморфные так и неполиморфные запросы работают быстро и можно с легкостью писать запросы вручную. Можно не применять сложные соединения или объединения. Эволюция схемы происходит довольно просто.

Главная проблема - целостность данных. Столбцы для свойств, объявленных в подклассах, могут содержать `null`. Если каждый подкласс объявляет несколько свойств, которым нельзя присваивать `null`, отказ от ограничения `NOT NULL` может стать серьезной проблемой с точки зрения корректности данных. Простая программная ошибка в приложении может привести к некорректным данным.

Другим важным аспектом является нормализация. Создается функциональная зависимость между неключевыми столбцами, нарушается третья нормальная форма.
Денормализация с целью повышения производительности может оказаться обманчивой, поскольку приходится жертвовать долговременной стабильностью, удобством сопровождения и гарантией целостности данных, ради сиюминутных приобретений, которые также можно достигнуть надлежащей оптимизацией планов выполнения SQL.

Для создания отображения с одной таблицей для целой иерархии классов используется стратегия наследования `SINGLE_TABLE`:
```
@Entity
@Inheritance(strategy = InheritanceType.SINGLE_TABLE)
@DescriminatorColumn(name = "BD_TYPE")
public abstract class BillingDetails {
	@Id
	@GeneratedValue(generator = Constants.ID_GENERATOR)
	protected Long id;
	
	@NotNull
	@Colum(nullable = false)
	protected String owner;
	//...
}
```

Hibernate требует определить возможность присваивания `null`, используя аннотацию `@Column`, поскольку при генерации схемы Hibernate игнорирует аннотацию `@NotNull` из Bean Validation.

Для различия типов записей необходимо определеить столбец селектора. Столбец называется `BD_TYPE`, а его значениями являются строки. Hibernate автоматически устанавливает и извлекает значения селектора.

Если не определить столбец селектора в суперклассе, по умолчанию он будет называться `DTYPE`, а его значениями будут строки. Каждый конкретный класс в иерархии наследования может задавать свое значение селектора с помощью аннотации `@DescriminatorValue("CC")`. 

Так же можно пользоваться аннотацией `@DiscriminatorFormula("case when CARDNUMBER is not null then 'CC' else 'BA' end")`.

Недостатки такой стратегии могут оказаться слишком серьезными для проекта - денормализованные схемы в долгосрочной перспективе могут превратиться в тяжкое бремя.

## 6.4 Одна таблица для каждого подкласса с использованием соединений

