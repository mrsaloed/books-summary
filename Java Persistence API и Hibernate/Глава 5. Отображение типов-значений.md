## 5.1 Отображение полей основных типов

При отображении хранимого класса, будь то сущность или встраиваемый тип (подробнее далее 5.2), каждое его свойство по умолчанию считается хранимым. К свойства хранимого класса по умолчанию применяются следующие правила JPA:

- если свойство имеет простой тип или это обертка простого типа, оно автоматически становится хранимым.

- иначе, если класс отмечен аннотацией `@Embeddable` или само свойство отображается как `@Embedded`, Hibernate отобразит свойство как встроенный класс-владельца.

- иначе, если свойство имеет тип `Serializable`, значение сохраняется в сериализованной форме.

- иначе, в момент запуска Hibernate возбудит исключение, сообщая о неизвестном типе свойства.

Согласно такому подходу, известному как _конфигурация исключением (configuration by exception),_ не требуется отмечать свойство аннотацией, чтобы сделать его хранимым; настраивать отображение придется лишь в крайнем случае.

Чтобы исключить свойство, отметьте поле или его метод чтения аннотацией `@Transient` или используйте ключевое слово `transient` (оно распознается реализациями JPA).

Если вы не хотите полагаться на отображение свойств по умолчанию, примените к конкретному свойству аннотацию `@Basic.` У нее два параметра, `optional` и `fetch`. Чтобы объявить о возможности присвоить значение null, большинство инженеров вместо аннотации `@Basic` использует более универсальную аннотацию `@Column.` Параметр `fetch` будет рассматриваться в главе 12.1.

Таким образом, существует три способа объявления обязательного наличия значения в свойстве: `@Basic (optional = false)`, `@Column (nullable = false)`, `@NotNull` из Bean Validation. Все они влияют на реализацию JPA одинаково: проверка при сохранении и генерация ограничения `NOT NULL` в схеме БД.

С помощью аннотации `@Column` также можно переопределить имя столбца в БД:  
`@Column (name = “ANOTHER_NAME”)`. Кроме того, эта аннотация имеет еще несколько параметров, которые управляют именем _каталога_ и _схемы_.

### Настройка доступа к свойствам

Механизм хранения обращается к свойствам класса либо напрямую, через поля, либо косвенно, через методы доступа. Если обязательную аннотацию `@Id` поместить над полем, а не над методом чтения, все остальные аннотации отображения в этой сущности должны применяться к полям. Аннотации никогда не размещаются над методами записи.

Любой встроенный класс, отмеченный аннотацией `@Embedded`, наследует либо стратегию доступа по умолчанию, либо определенную явно стратегию корневого класса-владельца. Кроме того, Hibernate обращается к любым свойствам с аннотацией `@MappedSuperclass`, используя либо стратегию доступа по умолчанию, либо определенную явно стратегию отображаемого класса сущности.

Спецификация JPA определяет аннотацию `@Access` для переопределения поведения по умолчанию при помощи параметров `AccessType.FIELD` и `AccessType.PROPERTY`. Если поместить аннотацию `@Access` на уровне класса/сущности, Hibernate будет обращаться ко всем свойствам класса на в соответствии с выбранной стратегией. Все аннотации отображения, включая `@Id`, должны помещаться либо над полями, либо над методами **чтения** соответственно.

Для переопределения стратегии доступа к отдельным свойствам можно использовать также аннотацию `@Access`.

### Работа с вычисляемыми полями

Значение вычисляемого свойства – это результат SQL-выражения, объявленного при помощи аннотации Hibernate `@Formula`.

При использовании этой аннотации SQL-формулы вычисляются каждый раз при загрузке сущности из БД и ни в какое другое время, поэтому результат может оказаться устаревшим, если другие поля изменятся.

Hibernate также поддерживает разновидность формул, называемую _преобразователями столбцов (column transformers),_ которые позволяют использовать произвольное SQL-выражение для чтения _и_ записи значения свойства.

### Преобразование значений столбцов

Аннотация Hibernate:

`@ColumnTransformer (read = “IMPERIALWEIGHT / 2.20462”, write = “? * 2.20462”)`

При чтении записи из таблицы будет выполнено выражение read в базе данных, и Hibernate вернет уровню приложения значение в метрической системе. Перед записью в столбец Hibernate подставит метрическое значение на место единственного обязательного параметра (знака вопроса), и выражение SQL вычислит значение для вставки или изменения.

Так же это преобразование будет применяться в запросах с `where`. Из-за этого, БД, скорее всего, не сможет использовать индекс.

### Значения свойств, генерируемые по умолчанию

Иногда, значения свойств генерирует БД – как правило, при вставке. Например: отметка времени создания, цена товара по умолчанию, триггеры, срабатывающие при каждом изменении.

Если отметить свойства как генерируемые базой данных с помощью аннотации `@Generated`, приложение переложит обновление экземпляра сущности на Hibernate. По сути, каждый раз, когда Hibernate будет выполнять `Insert` или `Update` для сущности с генерируемыми свойствами, он тотчас же выполнит `SELECT` для получения их значений.

Аннотация `@Generated` имеет всего два параметра: `ALWAYS` и `INSERT`. Первая будет получать обновления всегда, вторая, только для операций `INSERT`.

### Свойства для предоставления времени

Спецификация JPA требует, чтобы свойства, предоставляющие время, отмечались аннотацией `@Temporal` для более точного определения SQL-типов данных столбцов. (На самом деле аннотации не нужны, если к свойству применяется или может применяться _конвертер_. См. далее).

Доступными вариантами `TemporalType` являются `DATE`, `TIME` и `TIMESTAMP`. По умолчанию Hibernate выбирает `TIMESTAMP`.

Аннотации `@CreationTimestamp` и `@UpdateTimestamp` – напоминают аннотацию `@Generated`, вынуждая Hibernate автоматически генерировать значение поля.

Кроме того, имеется возможность создавать и настраивать собственные генераторы значений. Для этого надо ознакомиться с аннотациями Hibernate `GeneratorType` и `ValueGenerationType`.

### Отображение перечислений

Тип перечисления – это известная в языке Java идиома представления класса с постоянным (небольшим) количеством неизменяемых экземпляров.

Отображение перечислений происходит с помощью аннотации `@Enumerated`, которая принимает два параметра: `EnumType.STRING` и `EnumType.ORDINAL` – по умолчанию.

Сохранения порядкового номера довольно опасное поведение по умолчанию – если вы внесете изменения в перечисление, существующие значения больше не будут отображаться на те же позиции. Лучше выбирать `STRING` – Hibernate сохранит строковое представление значения перечисления.

## 5.2 Отображение встраиваемых компонентов

_Агрегация_ – отношение _часть целого_. Агрегация – это жесткая форма ассоциации. _Композиция_ – еще более жесткая форма, когда жизненный цикл части полностью зависит от жизненного цикла целого. Обычно класс, предоставляющий часть композиции, становится потенциальным типом-значением в объектно-реляционном отображении.

Первичным ключом является отображенный в БД идентификатор сущности-владельца. Встроенный компонент обладает зависимым жизненным циклом: при сохранении экземпляра сущности-владельца сохраняется экземпляр компонента. Экземпляр компонента удаляется при удалении экземпляра сущности-владельца.

### Встраиваемые классы

Отличие встраиваемого класса (компонента) от сущности – это идентификатор в БД: у класса компонента нет собственной идентичности, следовательно, ему не требуется поле идентификатора или его отображения.

Вместо `@Entity` компонент POJO отмечен аннотацией `@Embeddable`. Идентификатор отсутствует.

Все свойства встраиваемого класса по умолчанию сохраняются точно так де, как свойства хранимой сущности. Отображение свойств можно настраивать с помощью тех же аннотаций `@Column` или `@Basic`.

Встраиваемые компоненты наследуют стратегию доступа от сущности-владельца. Так же можно:

- поставить аннотацию `@Access` над свойство класса сущности-владельца

- поставить аннотацию над самим встраиваемым классом.

### Переопределение встроенных атрибутов

Если необходимо хранить еще один экземпляр встраиваемого класса, например address и billingAddress, то будет конфликт отображения. Для хранения еще одного экземпляра понадобятся дополнительные столбцы.

Аннотация `@AttributeOverrides` выборочно переопределяет отображение свойств встроенного класса.

Каждая аннотация `@AttributeOverride` перед свойством-компонентом является «конечной»: любые аннотации JPA или Hibernate над переопределяемым свойством будут игнорироваться.

Аннотации `@AttributeOverride` можно размещать на любом уровне. К вложенным полям можно обращаться через точку, например: `@AttributeOverride(name=”city.name”)`.

## 5.3 Отображение типов Java и SQL с применением конверторов

==Доделать, пока не надо==