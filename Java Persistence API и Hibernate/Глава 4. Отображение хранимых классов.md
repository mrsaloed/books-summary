## 4.1 Понятие сущностей и типов-значений

Экземпляр типа **сущности** можно извлечь, используя его хранимую идентичность. Ссылка (JVM) на экземпляр сущности сохраняется как ссылка в БД (значение, ограниченное внешним ключом). У экземпляра сущности собственный жизненный цикл; он может существовать независимо от остальных сущностей. Выбранные классы предметной модели отображаются как типы сущностей.

У экземпляра **типа-значения** отсутствует хранимая идентичность; он принадлежит экземпляру сущности. Его время жизни определяется экземпляром сущности-владельца. Тип-значение не поддерживает разделение ссылок. Наиболее очевидные типы-значения – это все классы, объявленные в JDK, такие как String, Integer, а также все примитивные типы. Также можно отображать классы модели предметной области как типы-значения.

По JPA типы-значения — это разделение на _базовые типы_ (basic property types) или *встраиваемые классы (embeddable classes)*.

В случае сталкивания со смешанным поведением (непонятно, что это, тип-сущности или тип-значение): объявлять все как тип-значение и переводить класс в разряд сущностей лишь при крайней необходимости. Попробовать упростить ассоциации – хранимые коллекции, к примеру, часто добавляют сложности, не давая никаких преимуществ.

## 4.2 Отображение сущностей с идентичностью

Наряду с идентичностью и равенством Java мы должны дать определение идентичности в базе дынных. Тогда, есть три правила различия ссылок:

- объекты идентичны, если они занимают одну область памяти в JVM. Это проверяется оператором `a==b`. Это понятие известно, как *объектная идентичность (object identity)*.
- объекты равны, если их состояние одинаково, что определяется методом `equals()`. Классы явно не переопределяющие этого метода, наследуют реализацию в классе Object, которая сравнивает идентичность объектов с помощью `==`. Это понятие известно, как _равенство объектов (object equality)_
- объекты, сохраненные в базу данных, идентичны, если находятся в одной таблице и у них одинаковый первичный ключ. На стороне Java это понятие известно, как _идентичность в базе данных (__database_ _identity)_.

### Выбор первичного ключа

Каждый класс сущности, помимо аннотации `@Entity`, должен иметь поле `@Id`; таким способом JPA раскрывает приложению идентичность сущностей в базе данных.

Если аннотация `@Id` находится над полем класса, реализация JPA будет обращаться к полям класса напрямую и по умолчанию считать их все частью сохраняемого состояния.
**Hibernate рассчитывает, что потенциальный ключ, выбранный в качестве первичного, неизменяем.**
_Естественный ключ_ – это ключ, имеющий смысл в предметной области: атрибут, уникальный в силу семантики предметной области. Рано или поздно, естественные ключи создают проблемы: хороший первичный ключ должен быть уникальным, неизменяемым и никогда не иметь значения `null`. Немногие атрибуты удовлетворяют этому или могут эффективно индексироваться. Кроме того, нужно быть уверенным, что потенциальный ключ никогда не изменится за десятилетия существования БД. Изменение значения ПК, а также всех ссылающихся внешних ключей является неприятной задачей. Кроме того, естественные ключи часто получаются _составными_. Они потенциально могут усложнить сопровождение, выполнение произвольных запросов и эволюцию схемы.

По этим причинам рекомендуется использовать _суррогатные ключи_.

Настройка подходов к формированию значений суррогатного ключа осуществляется с помощью аннотации `@GeneratedValue`.

JPA стандартизирует несколько стратегий формирования значений, используя перечисление `GenerationType`:
- `GenerationType.AUTO` – Hibernate выбирает подходящую стратегию, исходя из диалекта SQL. Значение по умолчанию.
- `GenerationType.SEQUENCE` – Hibernate ищет (и создает, при использовании определенных инструментов) последовательность HIBERNATE_SEQUENCE в БД. Эта последовательность будет вызываться отдельно перед каждой операцией INSERT для получения числовых последовательностей.
- `GenerationType.IDENTITY` – Hibernate ищет (и создает в DDL-определении таблицы) специальный столбец первичного ключа с автоматическим приращением, который сам генерирует числовое значение во время выполнения INSERT в БД.
- `GenerationType.TABLE` – Hibernate будет использовать дополнительную таблицу в БД, хранящую следующее числовое значение первичного ключа: по одной строке на каждый класс сущности. Эта таблица будет читаться и обновляться перед выполнением INSERT. По умолчанию это таблица `HIBERNATE_SEQUENCES` и содержит 2 столбца `SEQUENCE_NAME` и `SEQUENCE_NEXT_HI_VALUE`.

Рекомендуется настроить стратегию формирования значений первичного ключа явно: `@GeneratedValue(generator = “ID_GENERATOR”)`. Это _именованный_ генератор идентификаторов; теперь можно настраивать конфигурацию независимо от классов сущностей.

Если хранимый класс отметить только `@Entity`, по умолчанию для таблицы будет выбрано имя, совпадающее с именем класса. Переопределить имя таблицы можно использую JPA-аннотацию `@Table`. Она так же имеет параметры `catalog` и `schema`, если конфигурация вашей базы данных требует их наличия в качестве префиксов имени.

Hibernate узнает зарезервированные слова СУБД по настроенному диалекту БД и может автоматически ставить кавычки вокруг таких строк во время формирования SQL. Активировать автоматическое заключение в кавычки можно с помощью параметра `hibernate.auto_quote_keyword=true`.

Hibernate предоставляет возможность автоматического соблюдения стандартов именования. Можно реализовать Hibernate интерфейс `PhysicalNamingStrategy` или переопределить существующую реализацию. После реализации стратегии именования, ее необходимо активировать в `persistence.xml`. Так же есть `ImplicitNamingStrategy`. Она вызывается раньше, не на формировании окончательных имен артефактов.

По умолчанию Hibernate формирует SQL-выражения в момент создания единицы хранения на запуске. Сгенерированное SQL выражение обновляет все столбцы, и, если значение какого-либо столбца не изменилось, выражение присваивает ему старое значение. Чтобы деактивировать создание SQL-выражений `INSERT` и `UPDATE` при запуске, потребуются аннотации `@DynamicInser`t и `@DinamicUpdate`.

Hibernate может выполнять несколько оптимизаций – например, не проверять состояния объекта, когда отображается неизменяемый класс, для которого никогда не будет операций Update. Для этого используется аннотация `@Immutable`.

Отображение сущности в подзапрос. Аннотация `@Subselect`. Используется для создания представления уровня приложения – класс сущности с доступом только на чтение, отображаемый в SQL запрос SELECT. Все имена таблиц, упомянутые в запросе Select, должны быть перечислены в аннотации `@Synchronize`. Тогда Hibernate будет знать, что перед выполнением запроса к представлению, необходимо синхронизировать изменения в остальных таблицах с БД.